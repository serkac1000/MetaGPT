import tkinter as tk
from tkinter import scrolledtext
import asyncio
import threading

from metagpt.roles import Role
from metagpt.schema import Message
from metagpt.config2 import config
from metagpt.actions import Action

# Assume CodingAgent class is defined in coding_agent.py
# from coding_agent import CodingAgent

# Dummy Action classes for demonstration purposes
# In a real scenario, these would be your actual actions using tools
class WriteCodeAction(Action):
    async def run(self, instruction: str):
        # Simulate code generation with Gemini (replace with actual Gemini integration)
        print(f"Simulating Gemini code generation for: {instruction}")
        generated_code = f"print('Hello, {instruction}')\n# Generated by Gemini"
        return generated_code

class RunCommandAction(Action):
    async def run(self, command: str):
        # Simulate running a terminal command (replace with actual tool call)
        print(f"Simulating running command: {command}")
        result = f"Simulated output of: {command}\nExecution successful."
        return result

class ReadFileAction(Action):
    async def run(self, filename: str):
        # Simulate reading a file (replace with actual tool call)
        print(f"Simulating reading file: {filename}")
        content = f"Simulated content of {filename}:\nThis is a test file."
        return content


# Dummy CodingAgent class for demonstration purposes
# In a real scenario, this would be your actual CodingAgent class
class CodingAgent(Role):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._init_actions([WriteCodeAction, RunCommandAction, ReadFileAction])
        self._set_react_mode(react_mode="BY_ORDER") # Or other appropriate react_mode

    async def _act(self) -> Message:
        message = self.get_memories(k=1)[0] # Get the latest message
        print(f"CodingAgent received task: {message.content}")

        # Simple task routing based on keywords
        if "write code" in message.content.lower():
            todo = WriteCodeAction()
        elif "run command" in message.content.lower():
             todo = RunCommandAction()
        elif "read file" in message.content.lower():
             todo = ReadFileAction()
        else:
            # Default action or error handling
            return Message(content="Unknown task type. Please specify 'write code', 'run command', or 'read file'.",
                           role=self.profile, cause_by=Action())

        msg = await todo.run(message.content)
        return Message(content=msg, role=self.profile, cause_by=todo)


class AgentApp:
    def __init__(self, root):
        self.root = root
        root.title("Coding Agent")

        self.task_label = tk.Label(root, text="Enter Coding Task:")
        self.task_label.pack()

        self.task_input = scrolledtext.ScrolledText(root, wrap=tk.WORD, width=60, height=10)
        self.task_input.pack()

        self.send_button = tk.Button(root, text="Send Task", command=self.send_task)
        self.send_button.pack()

        self.response_label = tk.Label(root, text="Agent Response:")
        self.response_label.pack()

        self.response_output = scrolledtext.ScrolledText(root, wrap=tk.WORD, width=60, height=15)
        self.response_output.pack()

        self.agent = CodingAgent() # Initialize the agent

        # Run the asyncio event loop in a separate thread
        self.loop = asyncio.get_event_loop()
        self.loop_thread = threading.Thread(target=self.run_loop)
        self.loop_thread.daemon = True
        self.loop_thread.start()

    def run_loop(self):
        self.loop.run_forever()

    def send_task(self):
        task = self.task_input.get("1.0", tk.END).strip()
        if not task:
            return

        self.response_output.insert(tk.END, f"Sending task to agent: {task}\n\n")
        self.task_input.delete("1.0", tk.END)

        # Run the agent's action in the asyncio loop
        asyncio.run_coroutine_threadsafe(self.agent.run(task), self.loop)
        # In a real application, you would handle the agent's response asynchronously
        # and update the response_output when the agent is done.
        # For this simple example, we'll just indicate that the task was sent.


if __name__ == "__main__":
    root = tk.Tk()
    app = AgentApp(root)
    root.mainloop()